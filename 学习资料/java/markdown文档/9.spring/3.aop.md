## AOP

### 动态代理介绍

动态代理: 在不改变类的源代码的基础上，对类方法的功能进行增强。也可以起到消除重复代码的作用。

1. 方法

   1. Proxy.newProxyInstance   产生一个代理类
      1. 三个属性
         1. 类加载器  xxx.getClass().getClassLoader()
         2. 接口数组  xxx.getClass().getInterfaces()
         3. 处理器  new InvocationHandler()     扩展类方法的地方
            1. 代码逻辑编写的地方，代理对象调用所有的方法都会触发该方法执行
            2. 三个参数 ： proxy、method、args

   ```java
   public static void main(String[] args) {
           Lenovo lenovo = new Lenovo();
           /*
               三个参数:
                   1. 类加载器，真实对象.getClass().getClassLoader()
                   2. 接口数组, 真实对象.getClass().getInterfaces()
                   3. 处理器
            */
           SaleComputer proxy_lenovo = (SaleComputer) 
             Proxy.newProxyInstance(lenovo.getClass().getClassLoader(),
                                    lenovo.getClass().getInterfaces(), new InvocationHandler() {
               /*
                   代码逻辑编写的地方，代理对象调用所有的方法都会触发该方法执行
                   1. proxy 代理对象 就是 proxy_lenovo
                   2. method 代理调用的方法:
                   3. args 参数列表
                   增强 ：
                       1. 增强参数
                       2. 增强返回值
                       3. 增强方法体执行逻辑
                */
               @Override
               public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                   if (method.getName().equals("sale")) {
                       double money = (double) args[0];
                       money = money * 0.85;
                       System.out.println("专车接你");
                       String obj = (String) method.invoke(lenovo, money);
                       System.out.println("免费送货");
                       return obj+"__鼠标垫";
                   } else {
                       return method.invoke(lenovo, args);
                   }
               }
           });
           String computer = proxy_lenovo.sale(8000);
           System.out.println(computer);
       }
   ```

2. 简单数据库例子

   1. 编写正常的 dao/service/entity

      1. entity层， 就是 简单的javabean

      2. dao层， 实现连接，怎么连接无所谓，只要能连接

      3. service层， 引用dao层方法

         ```java
         @Service("accountService")
         public class AccountServiceImpl implements IAccountService {
             @Resource(name = "accountDao")
             private IAccountDao accountDao;
             public void setAccountDao(IAccountDao accountDao) {
                 this.accountDao = accountDao;
             }
             @Override
             public List<Account> findAll() {
                 return accountDao.findAll();
             }
             @Override
             public Account findOne(int id) {
                 return accountDao.findOne(id);
             }
         }
         ```

   2. 编写代理类

      ```java
      @Component("serviceProxy")
      public final class ServiceProxy {
          @Resource(name = "accountService")
          private IAccountService accountService; // 要代理的对象
          @Resource(name = "tcManagerUtil")
          private TransactionManagerUtil tcManager;
          public final void setAccountService(IAccountService accountService) {
              this.accountService = accountService;
          }
          public void setTcManager(TransactionManagerUtil tcManager) {
              this.tcManager = tcManager;
          }
          @Bean("accountServiceProxy")
          public final IAccountService getAccountService() {
              return (IAccountService) 
                Proxy.newProxyInstance(accountService.getClass().getClassLoader(), 
                                       accountService.getClass().getInterfaces(), 
                                       new InvocationHandler() {
                  @Override
                  public Object invoke(Object proxy, 
                                       Method method, 
                                       Object[] args) throws Throwable {
                      Object obj = null;
                      try {
                          // 1.开启事务
                          tcManager.beginTransaction();
                          // 2.执行操作
                          obj = method.invoke(accountService,args);
                          // 3.提交事物
                          tcManager.commit();
                          // 4.返回结果
                          return obj;
                      }catch (Exception e) {
                          // 5.回滚操作
                          tcManager.rollback();
                          throw new RuntimeException(e);
                      }finally {
                          // 6.释放链接
                          tcManager.release();
                      }
                  }
              });
          }
      }
      ```

   3. 使用代理类

      ```java
      @RunWith(SpringJUnit4ClassRunner.class)   // 调用spring-test提供的junit 无关
      @ContextConfiguration(classes = SpringConfiguration.class) // 导入 配置类。纯注解需要 无关项
      public class AccountServiceTest {
          @Autowired
          @Qualifier("accountServiceProxy") // 注入代理类   相当于从 以前注入service变成了注入代理类
          IAccountService as;
          @Test
          public void testFindOne() {
              Account account = as.findOne(5);
              System.out.println(account);
          }
          @Test
          public void testTransfer() {
              Account source = as.findOne(5);
              Account target = as.findOne(6);
              as.transfer(source.getAccount(),target.getAccount(), 100.0F);
      
          }
      }
      ```

### aop简介