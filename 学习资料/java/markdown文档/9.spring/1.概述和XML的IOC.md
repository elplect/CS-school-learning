### 概述

#### spring是什么

分层的Java SE/EE应用的full-stack轻量级开源框架

提供了 展现层spring mvc 和 持久层 spring jdbc 以及业务层事务管理等众多企业级应用技术

#### spring两大核心

IOC（反转控制）、AOP（面向切面编程）

#### 优势

和EJB相比。

方便解耦，简化开发

AOP编程的支持

声明式事物支持 

​	通过配置的方式

方便程序的测试

方便即成优秀框架

#### 体系结构

![image-20210303155210918](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20210303155210918.png)

### 程序的耦合和解耦

 耦合： 程序之间的依赖关系

1. 类间的依赖
2. 方法间的依赖

解耦： 降低程序间的依赖关系

 	实际开发 ： 编译时不依赖，运行时才依赖。

​		第一步 ： 使用反射来创建对象，避免使用new

​		第二步 ： 通过读取配置文件来获取要创建的对象的全限定类名

传统MVC： 耦合性太强

​	service 调用 dao，一个new

​	view调用service，一个new

解耦操作：

​	编写工厂类和配置文件，通过反射来创建对象(service、dao)

​	第一步： 需要一个配置文件来配置service和dao

​				配置的内容 ： 唯一标识 = 全限定类名(key = value)

​	第二部：通过读取配置文件的内容，反射创建对象

​				配置文件可以是xml，可以是properties

```java
public class BeanFactory {
    private static Properties props;
    private static Map<String,Object> beans;
    // 静态代码块只在类加载的时候执行 一次！！
    static {
        try {
            // 实例化对象
            props = new Properties();
            // 获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");
            props.load(in);
            // 实例化容器
            beans = new HashMap<String,Object>();
            // 取出配置文件中的所有key
            Enumeration keys = props.keys();
            while (keys.hasMoreElements()) {
                String key = keys.nextElement().toString();
                // 取出每个key
                String beanPath = props.getProperty(key);
                // 反射创建对象
                Object value = Class.forName(beanPath).getDeclaredConstructor().newInstance();
                // 把key和vaulue存入容器中
                beans.put(key,value);
            }
        } catch (Exception e) {
            throw new ExceptionInInitializerError("初始化properties失败");
        }
    }
    public static Object getBean(String beanName) {
        return beans.get(beanName);
    }
}

public static void main(String[] args) {
   IAccountService as = (IAccountService) BeanFactory.getBean("propertiesKey");
  // 即使 缺少了 IAccountSerive 的实现类， 也不会在编译器就报错。
}
```

### IOC概念和spring中的IOC

传统MVC 找对象 主动

![image-20210309155054619](../../../../../../../Library/Application%20Support/typora-user-images/image-20210309155054619.png)

工厂方式 ： 这种思想就是IOC(控制反转)

![image-20210309155144518](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20210309155144518.png)

叫控制反转的原因 ： 

​		控制权发生了转移，原始new 对象能够完全自主的找到自己真正想要的类

​		而IOC模式，将这种权利放弃了，把这权利交给了BeanFactory类，由BeanFactory通过固定名称找到对应类，至于是不是你能用的就不知道了。削减了程序的耦合。解除代码的依赖关系。

​		把创建对象的权利交给了框架。



IOC不能干什么，只能起到解除代码依赖关系的作用，解耦。

#### spring中基于XML的IOC环境搭建



### 依赖注入