### 1概述

#### spring是什么

分层的Java SE/EE应用的full-stack轻量级开源框架

提供了 展现层spring mvc 和 持久层 spring jdbc 以及业务层事务管理等众多企业级应用技术

#### spring两大核心

IOC（反转控制）、AOP（面向切面编程）

#### 优势

和EJB相比。

方便解耦，简化开发

AOP编程的支持

声明式事物支持 

​	通过配置的方式

方便程序的测试

方便即成优秀框架

#### 体系结构

![image-20210303155210918](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20210303155210918.png)

### 程序的耦合和解耦

 耦合： 程序之间的依赖关系

1. 类间的依赖
2. 方法间的依赖

解耦： 降低程序间的依赖关系

 	实际开发 ： 编译时不依赖，运行时才依赖。

​		第一步 ： 使用反射来创建对象，避免使用new

​		第二步 ： 通过读取配置文件来获取要创建的对象的全限定类名

传统MVC： 耦合性太强

​	service 调用 dao，一个new

​	view调用service，一个new

解耦操作：

​	编写工厂类和配置文件，通过反射来创建对象(service、dao)

​	第一步： 需要一个配置文件来配置service和dao

​				配置的内容 ： 唯一标识 = 全限定类名(key = value)

​	第二部：通过读取配置文件的内容，反射创建对象

​				配置文件可以是xml，可以是properties

```java
public class BeanFactory {
    private static Properties props;
    private static Map<String,Object> beans;
    // 静态代码块只在类加载的时候执行 一次！！
    static {
        try {
            // 实例化对象
            props = new Properties();
            // 获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");
            props.load(in);
            // 实例化容器
            beans = new HashMap<String,Object>();
            // 取出配置文件中的所有key
            Enumeration keys = props.keys();
            while (keys.hasMoreElements()) {
                String key = keys.nextElement().toString();
                // 取出每个key
                String beanPath = props.getProperty(key);
                // 反射创建对象
                Object value = Class.forName(beanPath).getDeclaredConstructor().newInstance();
                // 把key和vaulue存入容器中
                beans.put(key,value);
            }
        } catch (Exception e) {
            throw new ExceptionInInitializerError("初始化properties失败");
        }
    }
    public static Object getBean(String beanName) {
        return beans.get(beanName);
    }
}

public static void main(String[] args) {
   IAccountService as = (IAccountService) BeanFactory.getBean("propertiesKey");
  // 即使 缺少了 IAccountSerive 的实现类， 也不会在编译器就报错。
}
```

### IOC概念和spring中的IOC

传统MVC 找对象 主动

![image-20210309155054619](../../../../../../../Library/Application%20Support/typora-user-images/image-20210309155054619.png)

工厂方式 ： 这种思想就是IOC(控制反转)

![image-20210309155144518](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20210309155144518.png)

叫控制反转的原因 ： 

​		控制权发生了转移，原始new 对象能够完全自主的找到自己真正想要的类

​		而IOC模式，将这种权利放弃了，把这权利交给了BeanFactory类，由BeanFactory通过固定名称找到对应类，至于是不是你能用的就不知道了。削减了程序的耦合。解除代码的依赖关系。

​		把创建对象的权利交给了框架。



IOC不能干什么，只能起到解除代码依赖关系的作用，解耦。

#### spring中基于XML的IOC环境搭建

1. 创建工程，导入springframework

2. 创建xml -- 写入 <bean id='xx' class='com.elplect.xxx.xxx'> 

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:p="http://www.springframework.org/schema/p"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">
   <!--    把对象的创建交给spring来管理-->
       <bean id="accountService" class="com.elplect.service.impl.AccountServiceImpl"></bean>
       <bean id="accountDao" class="com.elplect.dao.impl.IAccountDaoImpl"></bean>
   </beans>
   ```

3. 创建核心容器对象

4. 根据id，从核心容器对象获取 bean对象。

   ```java
   /**
     * 获取spring容器的Ioc核心容器，并根据id获取对象
     * ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext 可以加载类路径下的配置文件，
     											 要求配置文件必须在类路径下，不在的话，加载不了
     *      FileSystemXMlAPplicationContext 可以加载磁盘人意路径下的配置文件(必须具备访问权)
     *      AnnotationCOnfigApplicationContext 用于读取注解创建容器的
     
     * 核心容器的两个接口引发的问题：
     
     *      ApplicationContext：  更多采用此接口定义
     *          在构建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，
     *          只要一读取完配置文件马上就创建配置文件中的配置的对象。(All)
     *              单例对象使用： 对象最好只创建一次，之后一直存在，一直被使用
   	*              但是 该接口十分智能，能自己知道对象是单例还是多例，自己改变策略
     *      BeanFactory：
     *          在构建核心容器时，创建对象采取的策略是采用延迟加载的方式，也就是说，
     *          什么时候根据id获取对象了，什么时候才真正创建对象。(One)
     *              多例对象： 对象要创建多次，
     *
     */
   public static void main(String[] args) {
     // 获取核心容器对象
     ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
     // 根据id获取bean对象
     IAccountService as = (IAccountService) ac.getBean("accountService");
     IAccountDao adao = (IAccountDao) ac.getBean("accountDao", IAccountDao.class);
     System.out.println(as);
     System.out.println(adao);
   
     // BeanFactory
     Resource resource = new ClassPathResource("bean.xml");
     BeanFactory factory = new XmlBeanFactory(resource);
     IAccountService as = (IAccountService) factory.getBean("accountService");
     IAccountDao adao = (IAccountDao) factory.getBean("accountDao", IAccountDao.class);
     System.out.println(as);
     System.out.println(adao);
   }
   ```

   #### springBean的细节

   把对象的创建交给spring来管理

   bean的标签：

   1. id
   2. class
   3. Scope: 作用范围
   4. init-method
   5. destroy-method
   6. Lazy-init : 是否立即加载，默认true，flase 延迟加载，在第一次使用bean的时候再加字啊
   7. name 别名
   8. 

   spring对bean的管理细节

   1. 创建bean的3种方式

      ```xml
      <!--
              第一种方式： 使用默认构造函数创建
                  在spring的配置文件中使用bean标签，配以id和class属性后，且没有其他属性和标签时
                      采用的就是默认构造函数创建，此时如果类中没有默认构造函数，则无法创建
      
      -->
          <bean id="accountService1" 
                class="com.elplect.service.impl.AccountServiceImpl"></bean>
      <!--
              背景：引入别人的jar包，引用别人写的类，无法通过修改源码的方式提供默认构造函数
              第二种方式： 使用普通工厂中的刚发创建对象(使用某个类中的方法创建对象，并存入spring容器)
      -->
          <bean id="instanceFactory"
                class="com.elplect.factory.InstanceFactory"></bean>
      
          <bean id="accountService2"
                factory-bean="instanceFactory" 
                factory-method="getAccountService"></bean>
      <!--
              背景：引入别人的jar包，引用别人写的类，无法通过修改源码的方式提供默认构造函数
              第三种方式： 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象，并存入容器)
      -->
          <bean id="instanceFactory" 
                class="com.elplect.factory.StaticFactory" 
                factory-method="getAccountService"></bean>
      
      ```

   2. bean对象的作用范围

      ```xml
      <!--    bean的作用范围调整
              默认： 单例
              scope属性：
                  作用：用于制定bean的作用范围
                  取值：singleton(默认、单例)
                       prototype 多例
                       request  作用于web应用的请求范围，将bean对象存入request
                       session  作用于web应用的会话范围，将bean对象存入session
                       global-session 作用域集群环境的会话范围，但不是集群环境，他就是session
      -->
          <bean id="accountService3" 
                class="com.elplect.service.impl.AccountServiceImpl"
                scope="prototype"></bean>
      ```

      ![image-20210310155358539](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20210310155358539.png)

   3. bean对象的生命周期

      1. 单例	

         1. ```java
            ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
            ```

         2. ```xml
            <!-- 	单例对象
                     出生：容器创建
                     死亡：容器死亡
                     生命周期 == 容器的生命周期
                     属性：init、destroy
            -->
                <bean id="accountService3"
                      class="com.elplect.service.impl.AccountServiceImpl"
                      scope="singleton"
                      init-method="init"
                      destroy-method="destroy"></bean>
            ```

         3. ```java
            ac.close(); // 不手动关闭，main结束后，内存关闭比你还快！就执行不了了
            ```

      2. 多例

         ```xml
         <!--  多例对象
                  出生：使用对象时才出生
                  活着：对象使用就一直活着。
                  死亡：当对象长时间不用，且没有别的对象引用，java的垃圾回收器回收
         -->
             <bean id="accountService3"
                   class="com.elplect.service.impl.AccountServiceImpl"
                   scope="prototype"
                   init-method="init"
                   destroy-method="destroy"></bean>
         ```

### 依赖注入





### 参考文献

1. [Spring基于XML方式的使用](https://www.cnblogs.com/liuyi6/p/10217096.html)   紫焱

   