## 第一章 线程状态

### 1.1 线程状态概述

当线程被创建并启动以后,它既不是一启动就进入了执行转台,也不是一直处于执行状态,在线程的生命周期中,有几种状态呢?在API中`java.lang.Thread.State`这个枚举中给出了六种线程状态:

这里先列出各个线程状态发生的条件,下面会对每种状态进行详细解析.

| 线程状态               | 导致状态发生条件                                             |
| ---------------------- | :----------------------------------------------------------- |
| NEW(新建)              | 线程刚被创建,但是并未启动还没有调用start方法                 |
| Runnable(可运行)       | 线程可以在java虚拟机中运行的状态,可能正在运行自己代码,也可能没有,这取决于系统处理器. |
| Blocked(锁阻塞)        | 当一个线程试图获取一个对象锁,而该对象锁正被其他线程持有,则该线程进入Block状态.当线程持有锁后,该线程变成Runnable状态 |
| Waitling(无限等待)     | 一个线程在等待另一个线程执行一个(唤醒)动作时,该线程进入Waiting状态.进入这个状态后是不可能自动唤醒的,必须等待另一个线程用notify或者notifyAll方法才能唤醒 |
| TimedWaiting(计时等待) | 同waiting状态,有几个方法有超时参数,调用他们将进入Timed waiting状态,这一状态将一直保持到超时期满或者接受到唤醒同志,带有超时参数的常用方法有Thread.sleep、Object.wait |
| Terminated(被终止)     | 因为run方法正常退出而死亡,或者因为没有捕获的异常终止了run方法而死亡 |

![image-20200916221226254](%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%AC%94%E8%AE%B0.assets/image-20200916221226254.png)



---

### 1.2 Timed Waiting(计时等待)

API描述:一个正在限时等待另一个线程执行一个(唤醒)动作的线程处于这一个状态.

在卖票案例中,为了减少线程执行太快,现象不明显,添加了sleep方法,以减慢线程.

当我们调用sleep方法后,线程就进入到Timed Waiting

---

### 1.3 BLOCKED(锁阻塞)

API描述:一个正在等待一个监视器锁(锁对象)的线程所处的状态.

---

### 1.4 Waiting(无限等待)

Waiting状态在API中介绍为:一个正在无限等待另一个线程执行一个特别的(唤醒)动作的线程处于这一状态.

也叫线程之间的通信

等待 和 唤醒 :`wait() 和 notify()`

```java
public static Object obj = new Object();
public static void main(String[] args) {
  // 要是能和iwaiting
  new Thread(new Runnable() {
    public void run() {
              Object object = new Object();
        new Thread(){
            @Override
            public void run() {
                while (true) {
                    // 保证等待和唤醒的线程只能有一个执行，使用同步技术
                    synchronized (object){
                        System.out.println("告知老板要的包子的种类和数量");
                        // 调用wait方法放弃cpu的执行，进入waiting状态
                        try {
//                            Thread.sleep(5000);
                            object.wait(5000);
                        }catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        // 唤醒之后执行的代码
                        System.out.println("我开动了！");
                    }
                }
            }
        }.start();
    }
  } 
}
```

---

##  第二章 等待唤醒机制

### 2.1线程间通信

**为什么要处理线程间通信:**

多个线程并发的时候,在默认情况下,CPU是随机切换线程的,当我们需要多个线程来共同完成一件任务,并且我们希望他们有规律的执行,那么多线程之间需要一些协调通信,以此来帮我们达成多线程共同操作一份数据.

**如何保证线程间通信有效利用资源:**

多个线程在处理同一个资源,并且任务不同时,需要线程通信来帮助解决线程之间对同一个变量的使用或操作.就是多个线程在操作同一份数据时,避免对同一共享变量的争夺,也就是我们需要通过一定的手段使各个线程能有效利用资源,这种手段就是————**等待唤醒机制**.

### 2.2 等待唤醒机制

**什么是等待唤醒机制**

这是多个线程间的一种协作机制.谈到线程经常想到的是线程间的竞争,但是线程之间偶尔也会协作.

一个线程逆行规定操作后进入等待状态(wait())

其他线程完成各自的指定代码后,唤醒(notify())

如果要唤醒多个,就notifyAll()

wait/notify是线程间的一种协作机制.

> 注意:哪怕只通知了一个等待的线程,被通知线程也不能立即恢复执行,因为它当初中断的地方是在同步块内,而此刻它已经不持有锁,所以他需要再次尝试获取锁(竞争),成功后才能在当初wait方法之后的地方恢复执行.

