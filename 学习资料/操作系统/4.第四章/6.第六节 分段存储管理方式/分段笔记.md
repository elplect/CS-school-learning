### 6.分段存储管理方式

引入分段存储管理方式的目的是为 满足程序员在编程和使用上多方面的要求,其中有些要求是其他几种存储管理方式难以满足的.

这种存储管理方式几乎已成为当今所有存储管理方式的基础.

#### 1.分段存储管理方式的引入

程序可分为若干个段(主程序段、子程序段...、数据段、栈段),每个段大多是一个相对独立的逻辑单位

同时 实现和满足信息共享、信息保护、动态链接以及信息的动态增长,也基本都是以段为基本单位的.

分段存储方式满足了程序员如下诸多要求 : 

##### 1. 方便编程

​		用户把自己的作业按照逻辑关系划分为若干个段,每个段都从0开始编址,并有自己的名字和长度.因此程序员迫切需要访问的逻辑地址是由段和段内偏移量决定的.. 不仅方便编程,还使程序更具可读性.

##### 2.信息共享

​		在实现对程序和数据的共享时,是以信息的逻辑单位(函数、文件、过程)为基础的.分页的页只是存放信息的物理地址,并无逻辑含义,分享工程可能需要数十个页面,这不利于实现共享.而段是逻辑单位,因此可以通过共享一个段,这就极大的简化了共享的实现.

##### 3.信息保护

​		也是以信息的逻辑单位为基础的.

##### 4.动态增长

##### 5.动态链接

​		动态链接是以目标程序(段)作为连接的基本单位的.

#### 2.分段系统的基本原理

##### 1.分段

​		在分段存储管理方式中,作业的地址空间被划分为若干个段,每个段定义了一组逻辑信息.

​		每个段都从0开始编址,并采用一段连续的地址空间.段的长度由相应的逻辑信息组的长度决定,因此各段长度并不相同.

​		整个作业的地址空间被分成若干个段,所以呈现出二维特性.每个段包含了一部分地址空间,又标示了逻辑关系.

​		逻辑地址(32位) = 段号(16位)[**段的物理地址**] + 段内地址(16位)

![IMG_4844](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4844.jpg)

在该地址结构中,允许一个作业最长有64K个段,每个段最大长度为64KB.

编译程序能自动根据源程序的情况自动生成若干个段.

##### 2.段表

​		在前面所介绍的动态分区分配方式中,系统为整个进程分配一个连续的内存空间.

​		而在分段式存储管理系统中,则是为每个分段分配了一个连续的分区.

​		进程中的各个段,可以离散地装入内存中的不同分区中.

​		为保证程序能正常的运行,就必须能从物理内存中找出每个逻辑段所对应的位置.因此为每个进程建立了一个段表.

​		每个段在表中占有一个表项,其中记录了该段在内存中的起始地址和段的长度.<img src="%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4845.jpg" alt="IMG_4845" style="zoom: 25%;" />

每个段都有一个段名,可用段号来简单替代段名.用来标识自身.

##### 3.地址变换机构

​		为了实现进程从逻辑地址到物理地址的变换功能. 要有一个 段表寄存器,用于存放段表始址和段表长度TL..

地址变换过程:

<img src="%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4846-6034490.jpg" alt="IMG_4846" style="zoom: 33%;" />

如果不增设快表,也要访问2次内存..但是由于段表比页表大,所以段表项的数目比页表项少,所以需要的联想存储器也相对较小..   与没有地址变换的常规存储器相比,存取速度慢10%~15%

##### 4.分页和分段的主要区别

|              | 分页                     | 分段                                                   |
| ------------ | ------------------------ | ------------------------------------------------------ |
| 分配方式     | 离散分配方式             | 离散分配方式                                           |
| 地址变换方式 | 地址映射机构             | 地址映射机构                                           |
| 信息单位     | 信息的物理单位           | 信息的逻辑单位                                         |
| 大小         | 固定,系统决定            | 不固定,取决于用户编写的程序,编译系统根据信息的性质划分 |
| 用户地址空间 | 一维(单一的线性地址空间) | 二维(标识一个地址,既要段名,也要段内地址)               |

#### 3.信息共享

允许若干个进程共享一个或多个分段,且对段的保护也十分简单易行.

##### 1.分页系统中对程序和数据的共享

​		不如分段系统方便.

​		多用户系统 40个用户 一个文件编辑程序(160KB的代码、40KB数据区) 需要8000KB内存支持40个用户

​		如果160KB的代码是可重入的,能被共享,只需在内存保存一个副本 内存空间需要40*40+160 来支持

​		而假设页面大小4KB  代码需要40个页面 数据需要10个页面.

​		为实现代码的共享,每个进程的页表都要建立40个页表项+10个页表项. 代码物理块号都是#21~#60,数据物理块号不同一次往后排.

<img src="%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4847.jpg" alt="IMG_4847" style="zoom:25%;" />

##### 2.分段系统中的程序和数据共享

​		在分段系统中,是以段为基本单位的.每个段都有一个段表项.共享段就很容易了.

​		仍以共享文件编辑程序为例,此时只需在进程1和进程2的段表,为文本编辑程序设置一个段表项.

​		可重入代码,是一种允许多个进程同时访问的代码.为使各个进程的代码完全相同,绝对不允许可重入代码在执行中有任何改变.

​		但是在代码执行过程,必然都会发生改变,比如控制执行次数的带啊么,指针数组等等...因此,在每个进程中都必须配以局部数据区,把执行过程中可能改变的部分拷贝到该数据区,这样程序在执行时,只需对该数据区中的内容进行改变,而不用去改变共享代码.

![IMG_4849](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4849.jpg)

#### 4.段页式存储管理方式

分页系统 : 有效提高内存利用率

分段系统 : 更好满足用户多方面的需求

如果能对两种存储方式“各取所长”,则形成了新的存储器管理方式———段页式存储管理方式

##### 1.基本原理

​		段页式系统的基本原理是分段和分页原理的结合,即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名. ![IMG_4850](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4850.jpg)

地址结构 = 段号 + 段内页号 + 页内地址

为了实现逻辑地址-->物理地址,系统中需要同时配置段表、页表

![IMG_4851](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4851.jpg)

##### 2.地址变换过程

​		段表寄存器 : 存放段表起始地址 + 段表长度TL![IMG_4852](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4852.jpg)

再段页式系统中,为了得到一条指令或数据,需要三次访问内存.

1. 访问内存中的段表,得到页表起始地址
2. 访问内存中的页表,获取物理块号,并将该块号和页内地址一起形成物理地址
3. 根据物理地址取出指令或数据

为了提高执行速度,再地址变换机构增设一个高速缓冲寄存器.每次访问它时,都须同时利用段号和页号去检索高速缓存,若找的到,便可直接得到物理块号.找不到就需要三次访问内存.原理类似分段和分页的联想寄存器.

