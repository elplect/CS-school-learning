### 5.分页存储管理方式

连续分配方式会产生许多“碎片”,虽然可以通过“紧凑”合成一个大空间,但开销很大.

如果允许将一个进程直接分散装入多个不连续的分区中,便可以有效利用内存,,而无需“紧凑”.

上述思想产生了离散分配方式.根据分配时所分配的地址空间的基本单位不同,可分为三类 :

1. 分页存储管理方式
   1. 将用户程序的逻辑地址空间分为**若干个固定大小**的区域,称为“页”或“页面”.**典型的页面大小为1KB**.相应地,**内存空间也分为若干个物理块或页框**,页和块的大小相同..这样一页放入一块中,实现了分离.
2. 分段存储管理方式
   1. 把用户程序的逻辑地址空间分为**若干个大小不同**的段,每段可定义一组相对完整的信息.在存储器分配时,以段为单位,这些段在内存中可以不相邻接,所以也采用了离散分配.
3. 段页式存储管理方式
   1. 结合产物,具备两者优点,目前应用较广泛的一种存储管理方式

#### 1.分页存储管理的基本方法

##### 1.页面和物理块

1. 页面
   1. 将进程的逻辑地址空间分成若干个页,并为其加上编号,从0开始.
   2. 将内存里的物理地址也分成若干块,0#块开始.
   3. 以块为单位分配内存,装入页. 最后一页装不满一块, 形成的不可利用碎片,称为“页内碎片”.
2. 页面大小
   1. 页面小 : 内存利用率高,但是进程页表过长,占用大量内存.降低页面换进换出效率,
   2. 页面大 : 内存利用率低
   3. 页的大小通常是2^k^,通常为1KB~8KB

##### 2.地址结构

​		分页地址的地址结构 : ![IMG_4820 2](%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4820%202.jpg)

W就是页内地址,每页大小4k.. 地址空间最多允许有1M页.

对于某特定机器,其地址结构是一定的,若给定**一个逻辑地址空间中的地址为A**,**页面的大小为L**,则:

- 页号$P = INT[\frac{A}{L}]$
- 页内地址d = [A] MOD L

##### 3.页表

​		在分页系统中,允许将进程的各个页离散地存储在内存的任一物理块中,为保证进程仍然能够正确的运行,就需要按照顺序找到所有在内存中的物理块,因此系统为每个进程建立了一张页表.所有页次在该页表有一个表项,记录了页相应的物理块号,配置表后,进程执行时通过查找该表就可以找到每页在内存中的物理块号..

​		因此,**页表的作用是实现从页号到物理块号的地址映射**.

<img src="%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4821.jpg" alt="IMG_4821" style="zoom: 25%;" />

即使在简单的分页系统中,也常在页表的表项中设置一存储控制字段,用于对该存储块中的内容加以保护.

当存储控制字段仅有一位时,可用来规定该存储块中的内容是允许读/写还是只读;

当存储控制字段为二位时,可规定为读/写,只读和只执行等存取方式.

如果有程序试图非法操作,就会引起操作系统一次中断.

如果要利用分页系统区实现虚拟存储器,还需要增设一个数据项.

#### 2.地址变换机构

作用 : 将用户地址空间的逻辑地址转换为内存空间的物理地址

在分页存储管理方式下,页的逻辑地址与物理块里的物理地址是一一对应的,因此地址变换机构的任务实际就是**将逻辑地址的页号转换为内存中的物理块号**...又因为这个工作页表的作用就是这个,所以,地址变换任务是借助于页表来完成的.

##### 1.基本的地址变换机构

​			进程在运行期内,需要对程序和数据的地址进行变换,也就是 **逻辑地址-->物理地址**,执行的频率非常高,因此需要硬件来实现.页表功能是由一组专门的寄存器来实现的.**一个页表项用一个寄存器**.但是寄存器太贵了,页表又可能很大,那么**只能让大多数页表驻留在内存,**那么怎么从内存中获取页表传到寄存器执行就是要解决的问题.

解决办法 : 在系统中只设置**一个页表寄存器PTR**,在其中存放**页表在内存的始址和页表的长度**.未执行时,页表的始址和页表长度存放在本进程的PCB中.当调度程序调度到某进程时,将这两个数据装入页表寄存器.因此,在单处理机下,虽然系统中可以运行多个进程,但只需要一个页表寄存器.

​			访问某逻辑地址中的数据,分页地址变换机构自动将有效地址分为页号和页内地址两部分,再以页号为索引去检索页表.

​			执行检索前,先将页号与页表长度进行比较,再将**页表始址**与**页号和页表项长度的乘积**相加,便得到**该表项在页表**中的位置,也就是**该页的物理块号**.将之装入**物理地址寄存器**中,与此同时,再将**有效地址寄存器中的页内地址**送入**物理地址寄存器的块内地址字段**中. 这样就完成了逻辑地址-->物理地址.

![IMG_4823](%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4823.jpg)

##### 2.具有快表的地址变换机构

​		由于页表是放在内存里,这使得CPU在每存存取一个数据时,都要**两次访问内存**.

1. 第一次是访问内存中的页表,从中找到指定页的物理块号,再将块号和页内偏移量W拼接,形成物理地址
2. 第二次访问内存,从第一次获得的物理地址中获取/写入数据.

因此采用这种方式会使得计算机的处理速度降低1/2.可见以高昂代价换取存储器空间利用率的提高是得不偿失的.

为了提高地址变换速度,可在地址变换机构中增设一个具有并行查询能力的**特殊高速缓冲存储器**,又称为“联想寄存器”(“快表”).用来存放当前的那些页表项.

此时地址变换过程 :

1. 在CPU给出有效地址后,地址变换机构自动将页号P送入高速缓冲寄存器,并将此页号与高速缓冲中的所有页号比较
   1. 有匹配的页号,便从快表中读取该页对应的物理块号,送入物理地址寄存器.   (1次访问内存)
   2. 没有,便再**访问内存中的页表,**把页表项中读出的物理块送入地址寄存器   (2次访问内存)
      1. 同时,将此表项存入快表里的一个寄存器单元,重新修改快表
      2. 若快表已满,就找一个已经不需要的页表项将其换出.
2. ![IMG_4833](%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4833.jpg)

由于成本问题,快表一般存放16~512个页表项. 快表找到所需页表项的概率90%+,增加了地址变换结构造成的损失减到10%以下.

#### 3.访问内存的有效时间

进程发出指定逻辑地址的访问请求--->地址变换--->内存找到实际物理地址--->到物理地址取出数据

这个过程所需要花费的总时间,称为内存的有效访问时间EAT

```java
访问一次内存时间t , 快表命中率a,快表访问时间m
分页存储管理(无快表) : EAT = 2t
分页存储管理(有快表) : EAT = am + (t+m)(1-a)+t = 2t+m-ta
```

| 命中率a | 有效访问时间EAT |
| ------- | --------------- |
| 0       | 220             |
| 50      | 170             |
| 80      | 140             |
| 90      | 130             |
| 98      | 122             |
| 100     | 110             |

由于引入了快表,CPU访问数据所耗时间明显减少

#### 4.两级和多级页表

现代大多数计算机系统都支持**非常大的逻辑地址空间**,在这样的环境下,**页表就变得很大**,**要占用相当大的内存空间**.

32位逻辑地址空间 : **页面大小4KB**,每个进程中页表项数可达1MB.. 而每个页表项占用1个字节,故每个进程仅仅页表就要占用1MB的内存空间,还要是连续的.显然不现实,但可以采用2个方法来解决这一问题:

1. 对于页表所需的内存空间,采用离散分配方式,以解决难以找到一块连续的大内存空间的问题
2. 只需将当前需要的部分页表项调入内存,其余仍驻留在磁盘上,留待调用.

##### 1.两级页表

​		针对难以找到大的连续的内存空间来存放页表的问题,可利用将页表进行分页的方法,使每个页面的大小与内存物理块的大小相同,并为其进行编号,即依次为0#页、1#页....,然后离散地将各个页面分别存放在不同的物理块中.同样,也要为离散分配的页表再建立一个页表,称为外层页表.在每个页表项纪录了页表页面的物理块号..![IMG_4834](%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4834.jpg)

地址变换机构:

![IMG_4835](%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4835.jpg)

为了方便实现地址变换,在地址变换机构同样增设一个外层页表寄存器,,用来存放外层页表的起始地址并用逻辑地址的外层页号作为外层页表的索引.从照找到页表分页的起始地址后,再利用P2作为指定页表分页的索引找到指定的页表项(物理块号).

该方法解决了**大页表无需大片连续存储空间的问题**,但是没有**解决用较少内存空间去存放大页表的问题**.

解决的唯一办法 : **仅把所需的部分页表项调入内存.**

二级页表下 ,外层页表必须装入内存.. 而外层分页只需调入几个,同时外层页表增设一个状态位S,表示在不在内存.

##### 2.多级页表

​		64位 : 把可直接寻址的存储器空间减少为45位,然后利用三级页表结构来实现分页存储管理

#### 5.反置页表

##### 1.反置页表的引入

​		在分页系统中,为每个进程配置了一张页表,进程逻辑地址空间的每一页,在页表中都对应有一个页表项.

​		在现代计算机系统中,通常允许一个进程的逻辑空间非常大,因此就需要很多页表项.也会占用很多内存.

​		为了减少页表占用的内存空间引入了反置页表.

​		反置页表 : **为每一个物理块设置一个页表项,并按照物理块的编号进行排序.内容是页号和其所隶属进程的标识符.**

##### 2.地址变换

​		书P144,建议看视频....太绕了

