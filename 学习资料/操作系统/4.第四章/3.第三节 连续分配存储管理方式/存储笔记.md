### 3.连续分配存储管理方式

将用户程序装入内存,需要为其分配一定大小的内存空间.

最早的存储器分配方式 : 连续分配方式

- 连续内存空间————代码和数据的逻辑地址相邻--->内存空间分配时物理地址相邻

连续分配方式分类 :

1. 单一连续分配
2. 固定分区分配
3. 动态分区分配
4. 动态可重定位分区分配

#### 1.单一连续分配

  单个分区

单道程序环境下,当时的存储器管理方式把内存分为系统区和用户区两部分,系统区仅供OS使用,通常放在内存的低址部分.在用户区只装有一个用户程序,即整个内存的用户空间由该程序独占,这样的存储器分配方式被称为单一连续分配方式..

存储器保护机构 : 防止用户程序破坏操作系统

#### 2.固定分区分配

  多个分区,分区大小固定

为了实现多道程序系统,将用户空间划分为若干个固定大小的区域,每个区域只装入一道作业.这就形成了最简单的一种可运行多道程序的分区式存储管理方式.

几个分区,允许几个程序并发运行.

##### 1.划分分区的方法

|          | 分区大小相等               | 分区大小不等               |
| -------- | -------------------------- | -------------------------- |
| 灵活性   | 不灵活,内存浪费            | 灵活                       |
| 适用领域 | 同时控制多个相同对象的场合 | 普遍场合                   |
| 特点     | 分区内存空间相等           | 多个小分区、适量中、少量大 |

##### 2.内存的分配

​		便于内存管理,通常将分区按其大小进行排队,并为之建立一张分区使用表.

分区使用表表项 :

1. 每个分区的起始地址
2. 大小及状态

用户程序装入---->内存分配程序按照用户程序大小检索分区使用表---->寻找满足要求、未分配的分区--->分配--->改变表项状态为”已分配“ (没找到,拒绝分配内存)

> 该分配方式通常用于控制多个相同对象的控制系统.

#### 3.动态分区分配

分区数目不固定,分区大小不固定.根据进程实际需要,动态分配内存空间..

实现问题 :分区分配用的**数据结构**、分区分配算法、分区的分配与回收

##### 1.数据结构

常见数据结构方式 : 

1. 空闲分区表
   1. 分区号、分区大小、分区地址
2. 空闲分区链
   1. 每个分区的起始部分 : 
      1. 控制分区分配的信息、连接各分区所用的前向指针
   2. 分区尾部 :
      1. 后向指针、重复设置状态位和分区大小表目

##### 2.动态分区分配算法

​		按照分配算法从空闲分区表或分区链选出分区分配.

##### 3.分区分配操作

​		动态分区存储管理方式中,主要操作是**分配内存**和**回收内存**

1. 分配内存
   1. size : 事先规定好的不再切割的分区大小
   2. ![IMG_4806](%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4806.jpg)
2. 回收内存
   1. 进程释放内存时,系统根据回收区的首址,从空闲区链/表 中找到合适的插入点 :
      1. ![IMG_4807](%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4807.jpg)
      2. 如果上下都没有空闲分区,单独建立一个新表项,填写回收区的首址和大小,并将首址插入空闲链合适位置.
   2. 流程:![IMG_4808](%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4808.jpg)

#### 4.基于顺序搜索的动态分区分配算法

通常通过将系统·空闲分区链接接成一个链,来实现动态分区分配.

顺序搜索是指依次搜索空闲分区链上的空闲分区,寻找合适分区.

基于顺序搜索的算法有四种 : 首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法

##### 1.首次适应算法FF

​		FF要求空闲分区链以地址递增的次序链接.

​		分配内存时,从链首开始顺序查找,直至找到合适大小的空闲分区.

​		按照作业的大小,从该分区划出一块内存空间分配.

该算法倾向于优先利用内存中低址部分的分区大小,保留了高址的大空闲区,为以后到达的大作业分配大的内存空间创造了条件.

缺点 : 低址部分不断被划分,会留下许多难以利用的、很小的空闲分区,称为碎片.  从链首重新开始查找,增加了查找的开销.

##### 2.循环首次适应算法NF

​		为避免上述缺点,循环首次适应算法在查找分区时,不是每次都从链首开始查找,而是从上次的分区的下一个开始查找.

​		为实现该算法,应设置一起始查询指针,用于指示下一次起始查询的空闲分区,并采用循环查找方式.

​		特点 : 减少查找空闲分区的开销,但会导致大的空闲分区的缺乏.

##### 3.最佳适应算法BF

​		每次分配内存时,总能把最小的空闲分区分配给作业,避免“大材小用”..

​		为了加速寻找,该算法要求所有的空闲分区按照其容量从小到大的顺序形成一空闲分区链.

​		这样第一次找到的空闲区必然是最佳的..然而每次切割后留下的空闲分区也是最小的,这样,存储器中也会留下许多难以利用的碎片.

##### 4. 最坏适应算法

​		与最佳适应算法采取的策略相反..它总是挑选最大的空闲区...以至于存储器中会缺乏大的空闲区.

​		优点 : 剩下的空闲分区不至于太小、查找效率高

​		缺点 : 缺乏大的空闲区,大作业难以分配内存

#### 5.基于索引搜索的动态分区分配算法

基于顺序搜索的动态分区分配算法,比较适用于不太大的系统..系统很大时,系统的内存分区会很多,相应的空闲分区链就会很长,顺序搜索就会很慢.

为了提高搜索空闲分区的速度,在大、中型系统中往往会采用**基于索引搜索的动态分区分配算法**,目前常用的有快速适应算法、伙伴系统和哈希算法.

##### 1.快速适应算法

​		该算法又称为**分类搜索法,**是将**空闲分区根据其容量大小进行分类**,对于每一类具有相同容量的所有空闲分区,单独设立一个空闲分区链表,系统中存在很多空闲分区链表.在内存设立一张管理索引表,其中的每一个索引表项对应了一种空闲分区类型,并记录了该类型空闲分区链表表头的指针.

> 空闲分区的分类是根据**进程常用的空间大小**进行划分的.

该算法搜索空闲分区的步骤 :

1. 根据进程的长度,从索引表中去寻找能容纳的最小空闲区链表
2. 从链表中取下第一块进行分配即可.

特点 : 该算法分配时不会对分区进行切割,所以能保留大的分区.满足对大空间的需求,也不会产生内存碎片.

优点 : 查找效率高

缺点 : 为了有效合并分区,在归还主存时的算法复杂,系统开销较大.

​			分配空闲分区时,是以进程为单位的,一个分区只能属于一个进程,因此分区或多或少存在一定的浪费,以空间换时间.

##### 2.伙伴系统

> ​		该算法规定,分区大小均为**2的k次幂**.

​		开始运行时,整个内存区是一个大小为$2^m$的空闲分区.在系统运行间不断分割形成若干个不连续的空闲分区,将这些空闲分区按大小进行分类.. 相同大小的空闲分区,单独设立一个空闲分区双向链表,不同大小的空闲分区就形成了k个空闲分区链表.

​		当需要分配一个长度为n的存储空间时,首先计算i,使得2^i-1^<=n<=2^i^ ,然后在空闲分区大小为$2^i$的空闲分区链表中查找.找到,到2^i+1^查找,若存在就把其分割为2个2^i^的分区,这2个分区称为一对伙伴..其中一个用于分配,另一个加入2^i^的空闲分区链表. 还找不到就继续往上,然后不停分割至2^i^的分区分配.

最坏的情况下可能要分割k次.

> 与多次分割一样,一次回收也可能要进行多次合并,直至所有空闲分区的大小都不相同.

伙伴系统中,大小为2^k^,地址为x的地址快,其伙伴块的地址则用$buudy_k(x)$表示,其通式为 :

1. x+2^k^  若x MOD 2^i+1^ = 0
2. x-2^k^   若x MOD 2^i+1^ = 2^k^

伙伴系统中,其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间,在回收空闲分区时,需要对空闲分区进行合并,所以时间性能比快速适应算法差,但由于它采用了索引搜索算法,比顺序搜索算法好.

空间性能 : 由于对空闲分区进行了合并,减少了小的空闲分区,提高了空闲分区的可使用率,故优于快速适应算法,比顺序搜索法略差.

> 当前操作系统**普遍采用**的是下面讲述的**基于离散分配方式**的**分页和分段机制**的**虚拟内存机制**.该机制较伙伴算法更为合理和高效,但在多处理机系统中,伙伴系统也是一种有效的内存分配和释放的方法,目前也被广泛使用.

##### 3.哈希算法

​		上述两种算法若对空闲分区**分类较细**,相应**索引表的表项**也就较多,会**显著增加**搜索索引表的表项的**时间开销**.

​		哈希算法利用**哈希快速查找的优点**,以及空闲分区在**可利用空闲区表**中的**分布规律,**建立哈希函数,构造一张**以空闲分区大小为关键字**的哈希表,该表的**每一个表项**纪录了一个对应的**空闲分区链表表头指针**.

​		当进行空闲分区分配时,根据所需空闲分区大小,通过哈希函数计算,得到在哈希表中的位置,从中得到相应的空闲分区链表,实现最佳分配策略.

#### 6.动态可重定位分区分配

##### 1.紧凑

​		连接分配方式的一个重要特点是,一个系统或用户必须被装入**一片连续**的内存空间中.当计算机运行一段时间后,它的内存空间会被分割成许多小的分区,缺乏大的分区.不能利用的小分区被称为“碎片”/“零头”.

​		要想利用这些分区,必须**将内存中的所有作业进行移动**,使他们全都**相邻接**.使**原本的小分区变成一个大分区**.这种方法称为“拼接”或**“紧凑”**.

​		但是紧凑之后,用户程序的内存位置也发生了变化,此时不对程序的地址加以修改,程序就无法执行.因此每次执行“紧凑”操作之后,都要对移动了的程序和数据进行重定向.为了提高内存利用率,紧凑的次数很频繁,每次都重定向,很麻烦也很影响效率..... 因此产生了下述的**动态重定位方法.**

##### 2.动态重定位

​		动态运行时装入的方式,作业装入内存后的所有地址仍然是相对地址.而相对地址转为物理地址的工作被推迟到了程序指令真正开始执行的时候,为使地址转换不会影响指令的执行速度,因此在系统中增设了一个**重定位寄存器**,**用它来存放程序在内存中的起始地址**,程序在执行时,真正范围的内存地址 = 相对地址+重定位寄存器中的地址.

地址变换过程实在程序执行期间,随着对每条指令或数据的访问自动进行的,故称为动态重定位.那么“紧凑”之后,只需要用该程序在内存的新起始地址去置换原来的起始地址即可.

![IMG_4809](%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4809.jpg)

##### 3.动态重定位分区分配算法

​		动态重定位分区分配算法与动态分区分配算法基本上相同,差别在于 : 在这种分配算法中,增加了紧凑的功能.当算法找不到足够大的空闲分区时,就会对内存进行“紧凑”.还小于,返回分配失败信息.

![IMG_4810](%E5%AD%98%E5%82%A8%E7%AC%94%E8%AE%B0.assets/IMG_4810.jpg)





