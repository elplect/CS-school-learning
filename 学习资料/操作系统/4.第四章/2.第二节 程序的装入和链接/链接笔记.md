### 2.程序的装入和链接

用户程序要在系统运行,必须先装入内存,然后再转变成一个可执行程序.经过以下几个步骤 : 

1. <span style="color:red">编译</span>,编译程序对用户源程序进行编译,生成若干个**目标模块**
2. <span style="color:red">链接</span>,**链接程序**将**编译后**形成的**一组目标模块以及所需要的库函数**连接在一起,形成一个完整的**装入模块**
3. <span style="color:red">装入</span>,由**装入程序**将装入模块**装入内存.**

![IMG_4774](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/IMG_4774.jpg)

#### 1.程序的装入

先介绍一个无需进行连接的单个目标模块的装入过程..讲一个装入模块装入内存时,有以下三种装入方式

##### 1.绝对装入方式

​		计算机系统很小,仅能运行单道程序时,完全有可能知道程序将驻留在内存什么位置.因此可采用绝对装入方式.

​		用户程序经编译后,将产生绝对地址(物理地址)的目标代码.

​		例如 : 实现已知进程驻留在从**R处开始的位置**,则编译程序产生的目标模块,便可以从**R处开始**往上扩展.绝对装入程序便可以按照装入模块中的地址,将程序与数据装入内存..装入模块装入内存后,由于程序中的**相对地址与实际内存地址相**同,所以**不需要对程序和数据的地址进行修改.**

​		程序中所使用的绝对地址既可以在编译或汇编的时候给出,也可以由程序员直接赋予.通常是在程序中采用符号地址,然后在编译或汇编时,再将这些符号地址转换为绝对地址.

##### 2.可重定位装入方式

​		绝对装入方式只能将目标模块装入到内存中事先制定的位置,只适用于单道程序环境.多道程序环境,编译程序不可能预知编译后所得到的目标模块应放在内存何处.

​		因此,对于用户程序编译形成的若干个目标模块,其实地址通常是从0开始的,程序中的其他地址也都是相对于起始地址计算的. 采用可重定位装入方式,根据内存的实际情况将装入模块装入到合适的内存位置.

> ​		此时,**装入模块的逻辑地址 与 装入后的实际物理地址 不同.**

逻辑地址 : 0开始

物理起始地址 : 选择合适的内存地址

物理地址 = 物理起始地址 + 逻辑地址

通常,把在装入时对目标程序中的指令和数据地址的修改过程称为重定向.

又因为地址变换通常时在进程装入时一次完成的,然后不再改变,又称为静态重定向.

##### 3.动态运行时的装入方式

​		可重定位装入方式可将装入模块装入到内存中任何允许的位置,故可以用于多道程序环境.但是该方式不允许程序运行时在内存中移动位置.非要移动,只能**修改程序的物理地址**后才能继续运行.

​		然而,运行过程中,**程序在内存中的位置可能要经常改变**..这时候就要采用动态运行时装入的方式.

​		动态运行时的装入程序在把装入模块装入内存后,并不立即**把装入模块中的逻辑地址转为物理地址**.**而是把这种地址转换推迟到程序真正要执行时才开始进行**.因此,装入内存后的所有地址仍旧还是逻辑地址,为了使地址转换不影响指令执行速度,还需要**重定位寄存器**的支持.

#### 2.程序的链接

**源程序经过编译后,可得到一组目标程序**,链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个**完整的装入模块.**

根据对目标模块链接的时间不同,可以把链接分为如下三类.

##### 1.静态链接方式

> ​	在程序运行之前,先将各目标模块及它们所需的库函数链接成一个完成的装配模块,以后不再拆开.

解决问题 : 对相对地址进行修改、变换外部调用符号

![image-20201117155017113](https://gitee.com/elplect/personal-image-bed/raw/master/beautyImg/image-20201117155017113.png)

##### 2.装入时动态链接

​		这是将用户源程序编译后所得到的一组目标模块,在装入内存时,采用**边装入边链接的链接方式**.即在装入一个目标模块时,若发生一个外部模块调用事件,将引起装入区去找出相应的外部目标模块,并将它装入内存..

优点 :

1. 便于修改和更新
2. 便于实现对目标模块的共享

##### 3.运行时动态链接

​		在许多情况下,应用程序运行时,每次要运行的模块可能是不同的,但由于事先无法知道本次运行要运行哪些模块,所以只能将所有要运行到的模块装入到内存中,并在装入时全部链接在一起.但是有部分目标模块根本不运行(错误处理目标模块),因此这是低效的.

> 实现方式 : 执行程序过程中,发现一个被调用模块尚未装入内存,立即去OS找该模块,并装入内存.将其链接到调用者模块.
>
> 优点 : 加快装入过程、节省大量时间



