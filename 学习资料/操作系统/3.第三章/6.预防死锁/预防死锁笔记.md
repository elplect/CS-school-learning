### 6.预防死锁

> 预防死锁的方法 : 通过破坏四个必要条件中的一个或几个.以避免发生死锁.
>
> ​	其中 互斥条件是非共享设备所必须的,所以不能改变.

#### 1.破坏“请求和保持”条件

要求做到 : 当进程请求资源时,不能持有不可抢占资源.通过下述2个协议可以实现 : 

1. 第一种协议
   1. 进程运行开始前,必须一次性申请运行过程中所需的所有资源. 使事件间具备原子性.
   2. 优点 : 简单、异行、安全
   3. 缺点 : 资源严重浪费、进程经常发生饥饿现象.(等待进程迟迟不能运行,因为资源被其他进程长期使用)
2. 第二种协议
   1. 允许进程只获得运行初期所需资源后,便开始运行
   2. 进程运行过程中再逐步释放已分配给自己的所有资源,再强求新的所需资源.

#### 2.破坏“不可独占性”条件

当一个已经保持了某些不可被抢占资源的进程,提出新的资源请求而不能满足时,必须释放已经保持的所有资源,待以后需要时再重新申请.

该方法实现复杂、代价大.... 牺牲了该进程此前的所有工作.

还可能因为反复申请和释放资源导致进程被无限期推迟,不仅延长周转时间,还增加了系统开销,降低了系统吞吐量.

#### 3.破坏“循环等待”条件

方法 : 对系统所有资源类型进行**线性排序,**并赋予不同的序号. 设R=(R1,R2,R3,...,Rm)为资源类型的集合,为每个资源类型赋予唯一的序号.

```c++
// 磁盘驱动器、硬盘驱动器、打印机
// 函数F
F(tape drive) = 1; // 磁盘
F(disk drive) = 5; // 硬盘
F(printer) = 12; // 打印机
// 必须按顺序请求 磁盘 硬盘 打印机
 // 如果顺序反了,必须释放已有的更高序列的资源,才能申请低的
```

在对系统所有资源类型进行线性排序后,便可采用预防协议 : **规定每个进程必须按序号递增的顺序请求资源.**

一个进程在开始时,可以请求某类资源Ri的单元,以后仅**当F(Rj)>F(Ri)时**,进程才可以请求资源Rj的单元.如果需要多个同类资源单元,则必须一起请求.

采用这种策略,如何规定每种资源的序号十分重要.通常应根据大多数进程需要资源的先后顺序来确定,一般情况,进程实现输入程序和数据,继而进行运算,最后将计算结果输出. 故可以为输入设备规定较低的序号,输出设备定位较高的序号.

这种预防死锁的策略与前两种相比,资源利用率和系统吞吐量有明显改善,但也存在下述问题 : 

1. 为系统中各类资源所规定的序号必须相对稳定,限制了新类型设备的增加
2. 在为资源的类型分配序号时,已经考虑到大多数作业在实际使用这些资源时的顺序,但也会发生状况 : 
   1. 作业使用各类资源的顺序与系统规定的顺序不同,造成资源的浪费
   2. 为方便用户,系统对用户在编程时所施加的限制条件应该尽量少,然后这种按规定次序申请的方法会限制用户编程.

