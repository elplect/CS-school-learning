### 8.死锁检测笔记

如果在系统中不采取预防、避免死锁机制.

还有两种算法能解决死锁问题...

1. 死锁检测算法
2. 死锁解除算法

#### 1.死锁的检测

为了能对死锁进行检测,系统必须 :

1. 保存有关资源的请求和分配信息
2. 提供一种算法,它利用这些信息来检测系统是否已进入死锁状态

##### 1.资源分配图

​		系统死锁,可利用资源分配图来描述,该图是由一组节点N和一组边E所组成的一个对偶G=(N,E),它具有下述形式的定义和限制.

1. 把N分为两个互斥的子集

   1. 一组进程节点 P={P1,P2,P3..Pn}
   2. 一组资源节点 R={R1,R2,R3..Rn}
   3. N = P U R

2. 集合E   E = {e1,e2,...,em}

   1. e={Pi,Rj}是**资源请求边**,由进程Pi指向资源Rj. 进程请求一个资源的Rj资源
   2. e={Rj,Pi}是**资源分配边**. 由资源Rj指向进程Pi... 把**一个单元的资源**分配给进程 (也就是一个点)

3. 资源分配图 : 圆圈代表进程  方块代表一类资源,方块中的一个点代表一个资源

   ​		<img src="%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0.assets/IMG_4756.jpg" alt="IMG_4756" style="zoom:20%;" />

##### 2.死锁定理

​	简化资源分配图,检测系统处于S状态是否为死锁状态.

简化方法如下 : 

1. 在资源分配图中,找出一个既不阻塞又非独立的进程Pi
   1. Pi获得所需资源,运行至结束,释放所有资源 == 消去Pi的请求变和分配边,成为孤立的节点
2. 重复简化操作后,若能消去图中所有边,节点都变成孤立状态,那么该图就是可完全简化的.
3. 不同的简化过程都将得到相同的不可简化图.

> **死锁定理**  :  S为死锁状态的充分条件 : 当且仅当S状态的资源分配图是不可完全简化的.

##### 3.死锁检测中的数据结构

​		类似银行家算法的数据结构

1. 可利用资源向量Available
2. 把不占用资源的进程计入L表 == Allocatio=0
3. 从进程集合中找到一个$Request_i<=Work$的进程,做如下处理
   1. 将其资源分配器简化,释放出资源,增加工作向量 Work = Work + Allocation
   2. 将它计入L表中
4. 若不能把所有进程计入L表,说明系统状态S的资源分配图是不可完全简化的.因此将发生死锁.

#### 2.死锁的解除

如果死锁检测算法检测出在系统中已发生了死锁,则立刻采取相应措施,以解除死锁.

- 通知操作员
- 利用死锁解除算法

解除算法有2种方法

1. 抢占资源
2. 终止进程
   1. 终止所有进程
   2. 逐个终止进程
      1. 每次终止都要死锁检测,直到检测安全,有足够资源使系统脱离死锁.
      2. 按照什么策略终止进程,能使得解除死锁付出的代价最小.
         1. 进程的优先级大小
         2. 进程已执行多少时间,还需多久能完成
         3. 进程在运行中已经使用资源的多少,以后还要多少资源.
         4. 进程的性质是交互式还是批处理式

##### 1.付出代价最小的死锁解除算法

​		书P118

​		