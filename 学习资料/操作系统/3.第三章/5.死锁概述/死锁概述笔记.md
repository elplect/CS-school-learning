### 5.死锁概述

复数进程请求复数临界资源,可能会发生死锁问题.

#### 1.资源问题

引起死锁的主要是 : 临界资源

##### 1.可重用性资源和消耗性资源

1. 可重用性资源 **系统中大部分资源都属于可重用性资源**
   1. 可供用户重复使用多次的资源
   2. 只能分配给一个进程使用,不允许多进程共享
   3. 使用顺序 : 请求资源、使用资源、释放资源
   4. 系统中每一类可充用性资源的单元数目都是相对固定的,进程在运行期间既不能创建也不能删除.
   5. 设备:request/release 文件:open/close 互斥资源:wait/signal
2. 可消耗性资源
   1. 可消耗性资源又称为**临时性资源**,在进程运行期间,由**进程动态创建和消耗**的.
   2. 每一类可消耗性资源的数目在进程运行期间是不断变化的.
   3. 进程运行间不断创造单元数,将它们放入**该资源类的缓冲区**中,以增加该资源类的单元数目.
   4. 进程可请求复数个资源单元,用于自己消耗,而不返回给资源类.
   5. 生产者创建、消耗者消费

##### 2.可抢占性资源和不可抢占性资源

1. 可抢占性资源
   1. 例如CPU和贮存
   2. 不会引起死锁
2. 不可抢占性资源

#### 2.计算机系统中的死锁

起因 : 源于多个进程对资源的争夺...

##### 1.竞争不可抢占性资源    图3-12

​		资源分配图 : 方块代表可重用的资源(文件),圆圈代表进程.

​		F1-->P1 代表F1已经分配给了P1

​		P1-->F2 代表P2请求F2资源

![IMG_4754](%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0%E7%AC%94%E8%AE%B0.assets/IMG_4754.jpg)

##### 2.竞争可消耗资源引起死锁    图3-13

​		现在进一步介绍竞争可消耗资源所引起的死锁.

​		图3-13展示了3个进程之间利用消息通信机制进行通信时所形成的死锁情况.

```c++
P1 send receive;
P2 send receive;
P3 send receive; // 不会发生死锁问题

p1 receive send;
P2 receive send;
P3 receive sned; // 3个进程都停留在等待阶段.
```

##### 3.进程推进顺序不当引起死锁

​		除了系统中的**多个进程对资源的竞争**会引发死锁外,进程运行过程中,对资**源进行申请和释放的顺序**,也是一个重要因素.

#### 3.死锁的定义、必要条件和处理方法

##### 1.死锁的定义

​		如果一组进程中的每一个进程都在等待仅有该组进程中其他进程才能引发的时间,那么该组进程是死锁的.

##### 2.产生死锁的必要条件

1. 互斥条件
2. 请求和保持条件
3. 不可抢占条件
4. 循环等待条件

##### 3.处理死锁的方法

1. 预防死锁
2. 避免死锁
3. 检测死锁
4. 解除死锁



