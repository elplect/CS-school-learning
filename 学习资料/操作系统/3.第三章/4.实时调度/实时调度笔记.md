### 4.实时调度

实时系统中, 存在两种不同性质的实时任务(HRT任务和SRT任务),它们都联系着一个**截止时间**

> 实时调度必须能满足实时任务对截止时间的要求

#### 1.实现实时调度的基本条件

##### 1.提供必要的信息

1. 就绪时间
2. 开始截止时间和完成截止时间
3. 处理时间
4. 资源要求
5. 优先级

##### 2.系统处理能力强

> ​	若处理能力不强.一些实时任务就无法及时处理.从而发生难以意料的后果.

1. m个周期性的**硬实时任务 HRT**, 处理时间表示为$C_i$,周期时间为$P_i$
   1. 单处理机下,只有满足   $\Sigma^m_i \frac{C_i}{P_i}<=1$,才能可调度....未考虑任务切换的时间,所以要适当留有余地.
   2. 多处理机下,处理机个数为N,只有满足   $\Sigma^m_i \frac{C_i}{P_i}<=N$,才能可调度.

##### 3.采用抢占式调度机制

> ​	在含有HRT任务的实时系统中,**广泛采用抢占机制**,可以满足HRT任务对截止时间的要求.但是这种机制比较复杂.

对于小的实时任务,如果能**预知任务的开始截止时间**,则对实时任务的调度可**采用非抢占调度机制.**以减少调度程序和任务调度的系统开销.

##### 4.具有快速切换机制

​		为保证硬实时任务能及时运行,系统中应具有快速切换机制.、

1. 对中断的快速响应能力.
2. 快速的任务分派能力

#### 2.实时调度算法的分类

根据**实时任务性质**分类 :

1. 硬实时调度算法
2. 软实时调度算法

根据**调度方式**分类 :

1. 非抢占式调度算法
   1. 非抢占式轮转调度算法
      1. 一台计算机控制若干相同对象,为之建立实时任务.并排成一个轮转队列.每次选择一个队首任务执行.任务完成挂在队列末尾等待.   获得数秒到数十秒的响应时间,用于不太严格的实时控制任务
   2. 非抢占式优先调度算法
      1. 优先级高的在队首. 响应时间数秒至数百毫秒
2. 抢占式调度算法
   1. 基于时钟中断的抢占式优先级调度算法
      1. 不立即抢占,等时间中断发生,再剥夺当前任务的执行.
      2. 调度延迟 降为几十至几毫秒
   2. 立即抢占的优先级调度算法
      1. 要求系统具有**快速响应外部时间中断**的能力
      2. 未处于**临界区**便能立即剥夺当前任务的执行
      3. 调度延迟 : 几毫秒至100微妙

#### 3.最早截止时间优先EDF算法

根据任务的截止时间确定任务的优先级..截止时间越早,优先级越高.

##### 1.非抢占式调度方式用于非周期实时任务

​			已经到达的任务,比较开始截止时间,谁早谁先运行.

##### 2.抢占式调度算法用于周期实时任务

​			采用最早截止时间优先算法. 截止时间早的先执行...

#### 4.最低松弛度优先LLF算法

> 根据任务的紧急程度确定任务的优先级. 

紧急程度(松弛程度) = (截止时间-已执行时间)[剩余时间] - 运行时间

按松弛度排列的实时任务就绪队列,松弛度低的在前面.

#### 5.优先级倒置

##### 1.优先级倒置的形成

当前OS广泛采用**优先级调度算法**和**抢占算法,**然而系统中存在着**影响进程运行的资源**而可能出现“优先级倒置”的现象.即**高优先级进程**被**低优先级进程**延迟或阻塞.

```c++
P1优先级最高
P1 P(mutex) CS-1 V(mutex);
P2 ....program....;
P3 P(mutex);CS-3;V(mutex);
P3 -> P2 -> P1(由于CS资源被P3占用,阻断) -> P2(执行时间无法确定) -> P3 -> P1;
最终P1的最晚截止时间无法保证..这种情况不应该出现在实时系统.
```

##### 2.优先级倒置的解决办法

​		一种简单的方法 : 规定假如P3进入临界区后,P3所占用的处理机就不允许被抢占.

​			问题 : 临界区都很短问题不大,若是临界区很长,那么P1仍会等待很长时间,效果还是无法让人满意.

​		一个比较实用的方法 : 建立在动态优先级继承基础上

​			该方法规定,当**高优先级进程P1**要进入**临界区**,去使用**临界资源R**,如果已有一个**低优先级进程P3**正在使用该资源,此时一方面**P1被阻塞**,另一方面由**P3继承P1的优先级,并一直保持到P3退出临界区**,这样做的目的在于**不让P2进程插进来**,导致延迟P3退出临界区.



