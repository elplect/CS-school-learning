## 5.请求分段存储管理方式

以分段为单位进行换入、换出的.

实现原理和所需硬件支持都是十分相似的.

#### 1.请求分段中的硬件支持

段表机制、缺段中断机构、地址变换机构

##### 1.请求段表机制

1. 主要数据结构 : 请求段表
   1. 访问字段A、修改为M、存在位P、外存始址 (请求分页也有的)
   2. 存取方式字段、增补位
   3. ![image-20201126205458802](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/image-20201126205458802.png)
      1. 存取方式 :  表明本段是只执行、只读，还是允许读/写。
      2. 访问字段A : 用于记录该段被访问的频繁程度
      3. 修改位M : 记录该段进入内存后是否被修改过
      4. 存在位P : 记录该段是否已调入内存
      5. 增补位 : 本段在运行中是否做过动态增长
      6. 表明本段在外存的起始盘号

##### 2.缺段中断机构

​		采用的是请求调段策略.每当发现运行进程所要访问的段尚未调入内存时,便由中断机构产生一个中断信号,进入OS后,由中断处理程序将所需的段调入内存.

​		中断机构需要在一条指令的执行期间产生和处理中断,以及在一条指令执行期间,可能产生多次中断.

![image-20201126211444049](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/image-20201126211444049.png)

##### 3.地址变换机构

​		**请求分段系统**的地址变换机构是在**分段系统**地址变换机构的基础上形成的.

​		因为被访问的段并非全在内存,所以在地址变换时,若发现所要访问的段不再内存,必须先将所缺的内存调入内存,并修改段表,然后才能利用段表进行地址变换.为此,在地址变换机构中增加了某些功能,比如 中断的请求及处理.=

#### 2.分段的共享和保护

分段存储管理的优点 : 便于实现分段的共享与保护,页介绍了实现分段共享的方法.

本小节介绍了 : 实现分段共享,还应配置相应的数据结构 —— 共享段表,以及对其的操作

<img src="%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/IMG_4912.jpg" alt="IMG_4912" style="zoom:25%;" />

#### 2.分段的共享和保护

分段共享的数据结构 : 共享段表

##### 1.共享段表

​		所有各共享段都在共享段表有一表项.

​		在表项上记录了共享段的 : 段号、段长、内存始址、存在位、外存始址、共享计数等信息

​			还记录了共享分段的每个进程的情况

![image-20201126220459494](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/image-20201126220459494.png)

1. 共享进程计数count
   1. 记录有多少进程正在共享此段.
   2. 进程不需要此段后,count--,当count==0,回收该段所占内存空间
2. 存取控制字段
   1. 对于共享段,应为不同的进程赋予不同的存取权限
3. 段号
   1. 在不同的进程有不同的段号,每个进程可用自己的段号去访问该共享段

##### 2.共享段的分配与回收

1. 共享段的分配
   1. 对第一个请求使用该共享段的进程,由系统为该共享段分配一物理区,再把共享段调入该区,同时将该去的始址填入请求进程段表的相应项中,还必须在共享段表中增添一表项,填入请求使用该共享段的进程名、段号和存取控制等有关数据,把count置为1.
   2. 当其他进程需要调用,只需在调用进程的段表增加一表项,填写该共享段的物理地址.在共享段的段表增加一个一个表项,count++;
2. 共享段的回收
   1. **当共享此段的某进程不再需要该段时，应将该段释放， 包括撤在该进程段表中共享段所对应的表项，以及执行**count=count-1操作。若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项， 表明此时已没有进程使用该段；否则(减1结果不为0)， 则只是取消调用者进程在共享段表中的有关记录。

##### 3.分段保护

1. 越界检查
   1. 通过段号和段长的比较
2. 存取控制检查
   1. 存取控制检查是以段为基本单位进行的.为此,在段表的每个表项都设置了一个“存取控制”字段,用来规定对该段的访问方式,通常的访问方式有:
      1. 只读
      2. 只执行 (只允许进程调用该段去执行,不准读该段的内容,也不准执行写操作)
      3. 读/写
   2. 存取控制检查是基于硬件实现的.
3. 环保护机构
   1. 机制规定
      1. 低编号的环具有高优先权.OS核心处于0号环内.
      2. 某些重要的实用程序和操作系统服务占据中间环.
      3. 一般的应用程序,被安排在外环上..
   2. 程序的访问和调用应遵循的规则 : 
      1. 一个程序可以**访问**驻留在相同环或较低特权环(外环)的数据
      2. 一个程序可以**调用**驻留在相同环或较高特权环(内核)的服务
      3. ![image-20201126222902634](%E5%88%86%E6%AE%B5%E7%AC%94%E8%AE%B0.assets/image-20201126222902634.png)



