### 3.页面置换算法

若访问页面不在内存,则需要调入内存,若内存无空闲空间,就要调出一页程序或数据到磁盘的对换区.

但是选取何页调出,就需要页面置换算法来选择.

置换算法的好坏将直接影响系统的性能.

不适当的算法将导致进程发生“抖动”

被换出的页很快又要被访问,需要将其重新调入,此时又要换出一页,这样频繁的话费大量时间在置换工作,称进程发生了“抖动”.

一个好的页面置换算法应具有较低的页面更换频率.

#### 1.最佳置换算法和先进先出置换算法

最佳置换 : 理论最优秀,然后现实实现不了.通常用来作为标准评价其他算法.

先进先出 : 最直接,但可能是性能最差的算法,实际应用非常少.

##### 1.最佳置换算法

​		被淘汰页以后永不使用.或者在**最长时间内不再被访问的页面**.采用该方法能获得最低的缺页率..

![image-20201123204713232](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201123204713232.png)

##### 2.先进先出页面置换算法

​		最早出现的置换算法.该算法总是淘汰最先进入内存的页面.实现简单.把一个进程已调入内存的页面按先后次序连接成一个队列,并设置一个指针,称为替换指针,

![image-20201123221834518](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201123221834518.png)

#### 2.最近最久未使用和最少使用置换算法

##### 1.LRU置换算法的描述

​		FIFO依据的是调入内存的时间,而页面调入的先后不能反映页面的使用情况.

​		最近最久未使用算法LRU : 根据页面调入内存后的使用情况作出决策的.由于无法预测使用情况,所以利用**”最近的过去“作为”最近的将来的近似“.**

​		因为LRU算法是选择最近最久未使用的页面予以淘汰.该算法赋予每一个页面**一个访问字段**,用来**记录一个页面自上次被访问以来所经历的时间t**,当需要淘汰一个页面时,选择现有页面中t值最大的页面予以淘汰.

![image-20201123232450393](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201123232450393.png)

##### 2.LRU置换算法的硬件支持

> 为了了解一个进程在内存中的各个页面各有多少时间未被进程访问,以及如何快速地知道哪一页是最近最久未使用的页面,需有寄存器和栈两类硬件支持.

1. 寄存器
   1. 需要为每个在内存中的页面配置一个移位寄存器. 记录某进程在内存中各页的使用情况
   2. 可表示为 : R=R~n-1~R~n-2~R~n-3~...R~2~R~1~R~0~
   3. 当进程访问某物理块时,要将相应寄存器的R~n-1~位置成1.每隔一定时间将寄存器右移一位.
   4. 如果把n位寄存器的数看成一个整数,那么具有最小数值的寄存器所对应的页面,就是最近最久未使用的页面.
   5. ![image-20201125233438683](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201125233438683.png)
2. 栈
   1. 利用一个特殊的栈保存当前使用的各个页面的页面号.
   2. 每当进程访问某个页面时,便将该页面的页面号从栈中移出,将它压入栈顶.
   3. 因此,栈顶始终是最新被访问页面的编号
   4. 栈底总是最近最久未使用页面的页面号,栈底就是被置换的那个
   5. ![image-20201126143817811](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201126143817811.png)

##### 3.最少使用置换算法LFU

​		在采用LFU算法时,要为内存中的每个页面设置**一个移位寄存器**,用来记录该页面被访问的频率.

​		该置换算法选择在最近时期使用最少的页面作为淘汰页.

​		用计数器来记录某页被访问的次数时不现实的,只能采用较大的时间间隔来记录对存储器的某页的访问.

1. 每次访问某页,便将其最高位置1,每隔一定时间右移一次.
2. 最近一段时间使用最少的页面 : R1+...+Rn 最小的页
3. LFU与的置换算法访问图和LRU的一样...硬件也是同一套的
4. 这种算法并不能真正反映出页面的使用情况

#### 3.Clock置换算法(最近未使用算法NRU)

虽然LRU是一种较好的算法,但是硬件支持要求太多,使得其成本太高,实际应用中,大多采用LRU的近似算法.

Clock算法是用的较多的一种LRU近似算法

##### 1.简单的Clock置换算法

​		只需要为每一页设置一个访问位,再将内存中的所有页面都通过链接指针链接成一个循环队列.

​		当某页被访问时,其访问位 置1.

​		置换算法在选择一页淘汰时,检查页的访问位.

​			为0,将该页换出.

​			为1,重新置0,暂不换出.按照FIFO算法检查下一个页面.

​			如果最后一个页面还是1,则回到队首检查第一个页面.

​		<img src="%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201126150420211.png" alt="image-20201126150420211" style="zoom: 67%;" /><img src="%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201126150759265.png" alt="image-20201126150759265" style="zoom: 67%;" />

##### 2.改进型Clock算法

​		页面换出 : 修改过,将页面重新写回到磁盘.没修改过,不拷回.修改过的页面,开销比较大.

​		改进型不仅考虑页面使用情况,还考虑置换代价. **换出的页面首选的是既未使用的、又未被修改过的页面。**

![image-20201126151444941](%E7%BD%AE%E6%8D%A2%E7%AC%94%E8%AE%B0.assets/image-20201126151444941.png)

内存中的每个页都必将是这四类页面之一.执行过程可分为以下三步:

1. 从指针所指示的当前位置开始,扫描队列,寻找A=0,M=0.
2. 第一步失败,开始找A=0,M=1... 扫描过的访问位都置0
3. 第二步失败,重新第一步,找 A=0,M=0
   1. 还失败,重复第二步,找A=0,M=1的第二类

> 该算法与简单的Clock算法比较,可减少磁盘的I/O操作次数.但为了找一个可置换页面,可能需要几轮扫描.实现算法本身开销增加了.

#### 4.页面缓冲算法PBA

请求分页系统中,由于进程在运行时经常会发生页面换进换出的情况,所以一个十分明显的事实就是 ; 

> 页面换进换出所付出的开销会对系统的性能产生重大的影响.

##### 1.影响页面换进换出效率的若干因素

​		影响页面换进换出效果的因素有很多,其中包括有:对页面进行置换的算法、将已修改页面写回磁盘的算法、以及将磁盘内容读入内存的频率.

1. 页面置换算法
   1. 影响页面换进换出效率最重要的因素.
   2. 影响缺页率,减少缺页带来的开销.
2. 写回磁盘的频率
   1. 在系统建立一个已修改换出页面的链表,则可以暂时不写回磁盘,而是将它们挂在已修改换出页面的链表上,在达到一定数目后,一起写回磁盘,这样显著减少了磁盘I/O的操作次数.
3. 读入内存的频率
   1. 设置换出页面链表,如果其中有需要被重新调用的页面,就可以从这里重新获取.

##### 2.页面缓冲算法PBA

PBA主要特点 :

1. 显著地降低了页面换进、换出的频率,使磁盘I/O的操作次数大为减少,因此减少了开销
2. 因为换进换出减少,因此可以使用简单的置换策略,如FIFO算法,不需要硬件支持,实现起来非常简单.

VAX/VMS : 内存分配采用了可变分配和局部置换.. 在内存设置了两个链表(空闲页面链表和修改页面链表)来显著降低页面换进换出频率.

#### 5.访问内存的有效时间

请求分页 比 基本分页存储管理方式,内存有效访问时间 不仅要考虑访问页表和访问实际物理地址数据的时间,还必须要考虑到缺页中断的处理时间.这样,在具有快表机制的请求分页管理方式中,存在下面三种方式的内存访问操作,其有效访问时间的计算公式也有所不同 :

1. **被访问页在内存中,且其对应的页表项在快表中**
   1. 此时不存在缺页中断,只需要考虑查询快表时间+访问实际物理地址所需时间
   2. $\lambda $  为查找快表的时间
   3. t  为访问实际物理地址所需的时间
   4.  $EAT = \lambda + t$
2. **被访问页在内存中,其对应的页表项不再快表中**
   1. 不存在缺页中断,但需要两次访问内存,还需要更新快表.
   2.  $EAT = 2(\lambda + t)$
3. **被访问页面不在内存中** 
   1. 需要进行缺页中断,比起2 多了个 缺页中断处理时间
   2. $\varepsilon$  为缺页中断处理时间
   3.  $EAT = \varepsilon + 2(\lambda + t)$
4. **考虑命中率a,和缺页率f**
   1. $EAT = \lambda +at+(1-a)[t+f(\varepsilon+\lambda +t)+(1-f)(\lambda +t)]$
5. **如果不考虑命中率,但考虑缺页率($\lambda =0,a=0$),设中断处理时间为$\theta$**
   1. f 为 缺页率、中断处理时间$\theta$
   2. $EAT=t+f(\theta+t)+(1-f)t$

