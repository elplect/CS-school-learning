### 4.设备驱动程序

设备处理程序通常又称为设备驱动程序.

它是I/O系统的高层与设备控制器之间的通信程序.

主要任务 : 

1. 接受上层软件发来的抽象I/O要求,如read或write命令.

   再把它转换为具体要求后,发送给设备控制器,启动设备去执行.

2. 将设备控制器发来的信号传送给上层软件.

由于驱动程序与硬件密切相关,故通常应为每一类设备配置一个驱动程序.

#### 1.设备驱动程序概述

##### 1.设备驱动程序的功能

​		为实现通信,需要以下功能 :

1. **接受**设备独立性软件发来的**命令和参数**,并将命令中的抽象要求**转换为**与设备相关的**低层操作序列**.

2. 检查用户I/O请求的**合法性**.了解I/O设备的**工作状态**.传递与I/O设备操作**有关的参数**,设置设备的**工作方式**.

3. 发出I/O命令,空闲,启动设备完成命令.

   设备忙绿,将请求块挂在设备队列上.

4. 及时响应由设备控制器发来的中断请求.根据中断类型,调用相应的中断处理程序.

##### 2.设备驱动程序的特点

​		设备驱动程序属于低级的系统程序.与其他软件有明显差异

1. 是实现软件和设备控制器之间的通信和转换的程序.
2. 与硬件密切相关,不同类型设备,有不同类型的驱动程序.
3. 驱动程序与I/O设备所采用的I/O**控制方式**紧密相关,常用的I/O控制方式是中断驱动和DMA方式.
4. 驱动程序与硬件紧密相关,因此其中一部分必须用汇编编写.
5. 驱动程序应允许可重入.

##### 3.设备处理方式

​		不同的操作系统,采用的处理方式不同.根据设备处理时是否设置进程、设置什么样的进程,把设备处理方式分为三类:

1. 为每一类设备设置一个进程,专门用于执行这类设备的I/O操作.
2. 在整个系统中设置一个I/O进程.
3. 不设置专门的设备处理进程,而只为各种设备设置相应的设备驱动程序,供用户或系统进程调用.目前使用较多.

#### 2.设备驱动程序的处理过程

主要任务 :启动指定设备,完成上层指定的I/O工作.

但启动之前,应先完成必要准备工作,检测设备状态是否为“忙”等.

完成所有准备工作后, 才能向设备控制器发送一条启动命令....

设备驱动程序的处理过程 :

1. 将抽象要求转换为具体要求
   1. 在每个设备控制器中有若干个寄存器,分别用于暂存命令、参数和数据.
   2. 转换工作由驱动程序完成.
   3. 只有驱动程序能同时了解抽象要求和设备控制器中的寄存器情况
2. 对服务请求进行校验
   1. 检查I/O请求,该设备能不能执行
3. 检查设备的状态
   1. 检查是否处于就绪状态
4. 传送必要的参数
   1. 向控制器的相应寄存器传送数据及与控制本次数据传输有关的参数.
      1. 两个控制寄存器:一个命令寄存器、一个方式寄存器
5. 启动I/O设备

处理机与I/O可以并行操作.

#### 3.对I/O设备的控制方式

对设备的控制,早期是使用轮询的可编程I/O方式.后来发展为使用中断的可编程I/O方式.

DMA控制器--->数据块为单位传输 : 大大改善了块设备的I/O性能.

I/O通道的出现 : 对I/O操作的组织和数据的传输可以独立进行,无需CPU参与.

I/O控制方式发展的宗旨 : 尽量减少CPU对I/O控制的干预.把主机从繁杂的I/O控制事物中解脱出来,以便更多地去完成数据处理任务.

##### 1.使用轮询的可编程I/O方式

​		处理机向控制器发出一条I/O指令,启动输入设备输入数据,同时把状态寄存器中的忙/闲标志busy置为1..然后不断地循环测试busy(称为轮询).

1. 当busy=1时,表示输入机尚未输完一个字**,处理机**应继续对该标志进行测试.
2. 当busy=0时,表明输入机已将输入数据送入控制器的数据寄存器.
   1. 接着,处理机将数据寄存器的数据去除,送入内存指定单元.便完成了一个字符的I/O.
   2. 然后读取下一个数据,并置busy=1

![IMG_5119](%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/IMG_5119.jpg)

在程序I/O方式中,CPU绝大部分时间处于等待I/O设备完成数据I/O的循环测试,CPU极大浪费.

因为缺少中断机构,I/O系统无法汇报CPU已完成一字符的输入.

##### 2.使用中断的可编程I/O方式

​		对I/O设备的控制,广泛采用中断的可编程I/O方式.

​		数据读入寄存器数据寄存起后,控制器便通过控制线向CPU发出中断信号.

​			CPU检查输入是否正确,正确,就向控制器发送取走数据的信号,然后通过控制器和数据线将数据写入内存指定单元.

​		CPU和I/O设备并行操作.

##### 3.直接存储器访问方式

1. 直接存储器访问方式的引入     解决一次只能穿出1字节/字的痛点

   1. 数据传输的基本单位是数据块
   2. 从设备---内存
   3. 尽在传输开始和结束,才需要CPU的干预

2. DMA控制器组成

   1. 由 : 主机与DMA的接口、DMA控制器与块设备的接口、I/O控制逻辑 三部分组成

      ![IMG_5163](%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/IMG_5163.jpg)

   2. 主要介绍 主机和DMA之间的接口

      1. 为了实现CPU和DMA之间块数据的直接交换,必须在DMA中设置如下四类寄存器
         1. 命令/状态寄存器CR
            1. 接受CPU发送的I/O指令、有关控制信息、设备状态
         2. 内存地址寄存器MAR
            1. 输入存放内存起始目标地址、输出存放内存源地址
         3. 数据寄存器DR
         4. 数据计数器DC
            1. 存放本次CPU要读或写的字(节)数

   3. DMA工作过程    CPU要从磁盘(外存)读入数据块

      1. 先向磁盘控制器发送一条读命令

      2. 命令送入命令寄存器CR

         同时,将本次要读入数据在内存的**起始目标地址**送入内存地址寄存器**MAR**中

      3. 将要读数据的字(节)数送入数据寄存器DC中.

         将磁盘中的源地址直接送至DMA控制器的I/O控制逻辑上.

      4. 启动DMA控制器进行数据传送.

         CPU处理其他任务,DMA控制接下来整个数据传输过程.

      5. DMA已从磁盘读入一个字(节)数据,并送入DR后

         再挪用一个存储器周期,将该字节传送到MAR所指示的内存单元.

      6. 然后MAR内容+1,DC内容-1

         1. DC !=0 传送未完,继续传送下一个字(节)
         2. DC ==0 发送中断请求

      7. <img src="%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.assets/IMG_5165.jpg" alt="IMG_5165" style="zoom: 25%;float:left" />

##### 4.I/O通道控制方式

1. I/O通道控制方式的引入

   1. DMA比起中断方式,已经显著减少了CPU的干预,但CPU每发出一条I/O指令,也只能去读写一个连续的数据块.

      现在要解决一次性 **传输多个数据块** 到不同的内存区的 问题.

      可以实现 CPU、通道和I/O设备三者的并行操作.

      一条指令 : 给出 通道程序首址、I/O设备

2. 通道程序

   1. 通道[通道程序、设备控制器]--->控制I/O设备
   2. **通道程序 : 一系列通道指令所构成的.**
   3. 通道指令 :
      1. 操作码 : 要执行的操作
      2. 内存地址 : 内存首址
      3. 计数 : 本条指令要读写的字节数
      4. **通道程序**结束位P
      5. 记录结束标志R
         1. R=0 表示本**通道指令**与下一条 同属于一个记录
         2. R=1 表示 这是处理某记录的最后一条指令

