### 7.缓冲区管理

现代操作系统 : 几乎所有I/O设备在与处理机交换数据时都用了缓冲区.

缓冲区是一个 存储区域.

​		可以用专门的硬件寄存器组成

​				存储器管理的联想存储器、设备控制器中的数据缓冲区

​		一般利用内存作为缓冲区

#### 1.缓冲的引入

原因 :

1. 缓和CPU和I.O设备速度不匹配的矛盾
2. 减少对PCU的中断频率,放宽对CPU中断响应时间的限制
3. 解决数据粒度不匹配的问题
   1. 生产者和消费者交换的数据单元大小不匹配
4. 提高CPU和I/O设备之间的并行性

#### 2.单缓冲区和双缓冲区

##### 1.单缓冲区

​		单缓冲区 : 每当用户进程发出一I/O请求时,操作系统便在主存中为之分配一缓冲区.

​		块设备输入 : 磁盘[数据]-->缓冲区 time = T

​							    缓冲区[数据]-->用户区  time = M

​								CPU处理数据 time = C

​								T 和 C是可以并行的.

​								time = T+M / C+M = Max(T,C) + M

​		字符设备输入 : 缓冲区暂存用户一行数据,若这一行数据还没提取完毕,第二行数据输出时,用户进程就会阻塞.

​		缺点 : 设备间不能并行操作

![image-20201212141526415](%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86.assets/image-20201212141526415.png)



##### 2.双缓冲区

​		缓冲对换

​		消除用户等待时间

​		实现双向数据交换

​		time = Max(C,T)

​			若C<T，则设备连续输入;

​			若C>T，可使CPU不必等待设备输入.

![image-20201212142147429](%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86.assets/image-20201212142147429.png)

#### 3.环形缓冲区

##### 1.环形缓冲区的组成

1. 多个缓冲区
   1. 装输入数据的空缓冲区R
   2. 装满数据的缓冲区G
   3. 计算进程正在使用的现行工作缓冲区C
2. 多个指针
   1. 指示计算进程下一个可用缓冲区G的指针Nextg
   2. 指示输入进程下次可用的空缓冲区R的指针Nexti
   3. 指示计算即成正在使用的缓冲区C的Current

##### 2.环形缓冲区的使用

​		计算进程和输入进程可使用下述两个过程来使用环形缓冲区.

1. Getbuf过程
2. Releasebuf过程

##### 3.进程之间的同步问题

​		输入进程和输出进程并行执行.

1. Nexti追上Nextg
   1. 输入速度>CPU处理速度
   2. 系统受计算限制
2. Nextg追上Nexti
   1. 输入速度<<CPU处理速度
   2. 系统受I/O限制

#### 4.缓冲池

利用缓冲池提高缓冲区利用率,而不是单纯的增设缓冲区.

缓冲区 : 一组内存块的链表

缓冲池 : 包含了一个管理的数据结构以及一组操作函数的管理机制,用于管理多个缓冲区

##### 1.缓冲池的组成

​		缓冲区 : 缓冲首部(标识和管理) + 缓冲体(数据)

​		三个队列 :  队首指针F(x) 、 队尾指针L(x)

​			空白缓冲队列 emq: 空缓冲区

​			输入队列 inq: 装满输入数据的缓冲区

​			输出队列 outq: 装满输出数据的缓冲区

​		四个工作缓冲区

​			收容输入数据的工作缓冲区

​			提取输入数据的工作缓冲区

​			收容输出数据的工作缓冲区

​			提取输出数据的工作缓冲区

##### 2.Getbuf过程和Putbuf过程

​		多个进程访问一个队列时,既应互斥,又需同步.

​		为了诸进程能互斥访问缓冲池队列,可为每一队列设置一个互斥信号量MS.

​		为了诸进程能同步使用缓冲区,可为每一队列设置一个资源信号量RS.

```c++
void Getbuf(unsigned type) {
  Wait(RS(type));
  Wait(MS(type));
  B(number) = Takebuf(type);
  Signal(MS(type));
}
void Putbuf(type,number) {
  Wait(MS(type));
  Addbuf(type,number);
  Signal(MS(type));
  Signal(RS(type));
}
```

##### 3.缓冲区工作方式

![IMG_5186](%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86.assets/IMG_5186-7928738.jpg)

1. 收容输入
   1. 输入进程调用getBuf(emq)过程,从**空缓冲队列**emq的队首摘下一个**空缓冲区**,把它作为收容输入工作区hin.
   2. 把数据输入其中,**装满数据后**调用Putbuf(inq,hin)过程,把它**挂在输入队列**inq上.
2. 提取输入
   1. 计算进程调用Getbuf(inq)过程,从**输入队列**inq上取得一缓冲区.作为提取输入工作缓冲区sin.
   2. 计算进程从中提取数据,用完数据后,调用Putbuf(emq,sin)将它**挂到空缓冲队列**emq.
3. 收容输出
   1. 计算即成调用Getbuf(emq),从空缓冲队列emq的队首取得一空缓冲区,作为收容输出空坐缓冲区hout.
   2. 装满数据后,调用Putbuf(outq,hout)过程,将它**挂在输出队列**outq末尾.
4. 提取输出
   1. 输出进程调用Getbuf(outq),从**输出队列**取得一装满输出数据的缓冲区,作为提取输出工作缓冲区sout.
   2. 数据提取完后,调用Putbuf(emq,sout)过程,将它**挂在空缓冲队列**末尾.